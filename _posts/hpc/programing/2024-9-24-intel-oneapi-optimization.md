---
layout:post
title: Intel OneAPI 优化手册
date: 2024-9-24
categories: OneAPI
---

# 1. Intel Xe GPU 架构

# 2. General-Purpose Computing on GPU

## 2.1. Execution Model Overview

## 2.2. Thread Mapping and GPU Occupancy

## 2.3. Kernels

### 2.3.1. Sub-Groups and SIMD Vectorzation

### 2.3.2. Removing Conditional Checks

### 2.3.3. Registerization and Avoiding Register Spills

**Registers and Performance**

寄存器是内存层次结构中最快的存储器。尽可能长时间地将数据保存在寄存器中对性能至关重要。 然而，寄存器空间有限，比内存空间小得多。例如，当前一代 Intel® GPU 每个 XVE 线程有 128 个通用寄存器，每个默认宽度为 32 字节。尽管编译器旨在将尽可能多的变量分配给寄存器，但有限数量的寄存器只能在执行过程中的某一时刻分配给一小组变量。一个特定的寄存器可以在不同时间保存不同的变量，因为不同时间需要不同的变量集合。如果没有足够的寄存器来保存所有变量，则寄存器可能会溢出，或者当前在寄存器中的某些变量可以移动到内存中以腾出空间给其他变量。

在 SYCL 中，编译器将寄存器分配给 work-item 中的私有变量。一个sub-group中的多个work-item被打包到一个XVE线程中。默认情况下，编译器使用寄存器压力作为选择SIMD宽度或sub-group大小的参考因素之一。如果没有显式指定sub-group大小，高寄存器压力可能导致较小的sub-group大小（例如8而不是16），这也可能导致寄存器溢出或导致某些变量无法提升到寄存器。

如果sub-group大小或SIMD宽度不是硬件支持的最大值，则硬件可能无法充分利用。寄存器溢出可能导致性能显著下降，特别是当溢出发生在热点循环内部时。当变量未提升到寄存器时，对这些变量的访问会导致内存访问显著增加。

尽管编译器使用智能算法在寄存器中分配变量并最小化寄存器溢出，但开发人员的优化可以帮助编译器做得更好，并且通常会产生很大的性能差异。

**Optimization Techniques**

以下技术可以减小寄存器压力：

* 尽可能缩短私有变量的生命周期。

尽管编译器调度指令并优化变量的距离，但在某些情况下， 在源码中将加载和使用相同变量移动得更近或删除某些依赖关系可以帮助编译器做得更好。

* 避免过度的循环展开。

循环展开可以让编译器看到更多指令调度优化的机会，从而提高性能。 然而，展开引入的临时变量可能会增加寄存器分配的压力并导致寄存器溢出。 实践中的好方法是比较带有和不带有循环展开以及不同次数展开的性能，以决定是否应该展开循环或展开多少次。

* 优先选择使用 USM 指针。

Buffer accessor 方式的访问占用的空间比 USM 指针多。 如果可以在 USM 指针和 buffer accessor 方式之间选择，请选择使用 USM 指针。

* 对于计算开销小的值，按需重新计算，而不是将它一直保留为变量，否则它会被长时间保存在寄存器中。
* 避免使用大数组或大结构，或者将大结构的数组拆分为多个小结构的数组。

例如，一个 sycl::float4 的数组：

    sycl::float4 v[8];

可以拆分为 4 个 float 数组:

    float x[8]; float y[8]; float z[8]; float w[8];

所有或部分 4 个 float 数组比 sycl::float4 数组更有可能被分配到寄存器中。

* 将一个大循环拆分为多个小循环，以减少同时活跃的变量数量。
* 如果可能，选择较小尺寸的数据类型。
* 不要将私有变量声明为 volatile。
* 在 sub-group 中共享寄存器。
* 如果可能，使用 sub-group 块来加载/存储。
* 尽可能使用共享本地内存（SLM）。

这里列举了一些技术，并不详尽。

本章的其余部分将展示如何在实际示例中应用这些技术，重点是最后五项。

**Choosing Smaller Data Types**
